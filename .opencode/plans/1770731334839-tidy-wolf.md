# GitHub Releases + Auto-Update Plan

## Summary

Add GitHub Releases binary publishing alongside existing npm publishing, an install script for direct binary installation, and a self-updating system that replaces the binary and stops all daemons.

## Phase 1: Types and State Persistence

### New file: `src/update-types.ts`

Shared types used across all update modules:

- `Platform = 'darwin' | 'linux'` (no Windows for install script / auto-update — Windows users use npm)
- `Architecture = 'x64' | 'arm64'`
- `UpdateBehavior = 'auto' | 'off'`
- `UpdateState = { lastCheckedAt: number }`
- `OperationResult<T> = { success: true; data: T } | { success: false; error: string }`

### New file: `src/update-state.ts`

State persistence functions (adapted from `repos/src/update-state.ts`):

- `getUpdateStatePath()` — returns `$XDG_STATE_HOME/cli-lsp-client-update-state` or `~/.cli-lsp-client-update-state`
- `readUpdateState(statePath)` — reads and validates state JSON
- `writeUpdateState(statePath, state)` — writes state JSON
- `shouldCheckForUpdate(state, intervalHours=24)` — cooldown check

### New file: `tests/update-state.test.ts`

Test state read/write, cooldown logic, missing/malformed file handling. Use temp files for filesystem tests.

## Phase 2: Core Update Functions

### New file: `src/update.ts`

Core update logic (adapted from `repos/src/update.ts`):

- `GITHUB_REPO = 'eli0shin/cli-lsp-client'`
- `getPlatform()` → `OperationResult<Platform>` using `os.platform()`
- `getArchitecture()` → `OperationResult<Architecture>` using `os.arch()`
- `getBinaryName(platform, arch)` → `cli-lsp-client-{platform}-{arch}`
- `isNewerVersion(current, latest)` → boolean, semver major.minor.patch comparison
- `isPrerelease(version)` → boolean, checks for `-` in version string
- `fetchLatestVersion()` → `OperationResult<{ version, downloadUrl }>` — calls `api.github.com/repos/{GITHUB_REPO}/releases/latest`, constructs download URL as `https://github.com/{GITHUB_REPO}/releases/latest/download/{binaryName}`
- `downloadBinary(url, targetDir)` → `OperationResult<string>` — downloads to temp file `.cli-lsp-client-update-{timestamp}`, chmod 755
- `replaceBinary(tempPath, targetPath)` → `OperationResult` — atomic `fs.rename()`, cleanup on failure

### New file: `tests/update.test.ts`

- Test `isNewerVersion` with various version combinations
- Test `isPrerelease` with release and pre-release strings
- Test `getBinaryName` for all platform/arch combos
- Test `getPlatform`/`getArchitecture` (use real runtime values)
- Mock `fetch` for `fetchLatestVersion` tests
- Use temp directories for `downloadBinary`/`replaceBinary` tests

## Phase 3: Auto-Update Orchestrator

### New file: `src/auto-update.ts`

Adapted from `repos/src/auto-update.ts`:

- `handleAutoUpdate(currentVersion, updateBehavior, checkIntervalHours, statePath?, spawnFn?)` — reads state, checks cooldown, spawns `--update-worker` as detached process via `Bun.spawn` with `detached: true, stdio: ['ignore','ignore','ignore']` then `.unref()`. Since we only have `auto` and `off`, if `off` return early, otherwise check cooldown and spawn.
- `SpawnFn` type for testability (injectable mock)

### New file: `tests/auto-update.test.ts`

- Test that spawn is called when cooldown expired
- Test that spawn is NOT called when within cooldown
- Test that `off` behavior skips spawn entirely
- Use injectable `SpawnFn` mock

## Phase 4: Updater Worker

### New file: `src/updater-worker.ts`

Background worker (adapted from `repos/src/updater-worker.ts`):

- `runUpdaterWorker()` — parses `process.argv` for `currentVersion`, `binaryPath`, `behavior`
- Calls `fetchLatestVersion()`, skips prereleases, compares versions
- If newer: downloads binary, replaces binary, **calls `stopAllDaemons()`** from `src/client.ts`, updates timestamp
- All errors are silently caught (background process, no stdout)

### New file: `tests/updater-worker.test.ts`

- Mock `fetch` and `stopAllDaemons`
- Test that `stopAllDaemons` is called after successful update
- Test that stale versions are skipped
- Test that fetch failures don't update timestamp

## Phase 5: Manual Update Command + Config Integration

### New file: `src/commands/update.ts`

Manual update command following existing `registerXxxCommand(program)` pattern:

- Shows current version
- Calls `fetchLatestVersion()` and `isNewerVersion()`
- Downloads and replaces binary
- **Calls `stopAllDaemons()`** after replacing
- Prints success/failure messages

### Modify: `src/lsp/config.ts`

Add `updateBehavior` to the existing config schema:

- Add `updateBehavior: z.enum(['auto', 'off']).optional()` to `ConfigFileSchema`
- Add `getUpdateBehavior(config: ConfigFile): UpdateBehavior` helper (defaults to `'auto'`)
- The config file at `~/.config/cli-lsp-client/settings.json` gains an optional `updateBehavior` field

### Modify: `src/cli.ts`

Three additions to the entry point:

1. **Early `--update-worker` detection** (before Commander, at top of `run()` or before it):
   ```typescript
   if (process.argv[2] === '--update-worker') {
     await runUpdaterWorker();
     process.exit(0);
   }
   ```
2. **Non-blocking auto-update** before Commander setup:
   ```typescript
   const config = await loadConfigFile();
   const updateBehavior = getUpdateBehavior(config);
   await handleAutoUpdate(packageJson.version, updateBehavior).catch(() => {});
   ```
3. **Register update command**: `registerUpdateCommand(program)`

## Phase 6: Install Script

### New file: `install.sh`

Adapted from `repos/install.sh` for cli-lsp-client:

- `REPO="eli0shin/cli-lsp-client"`
- `INSTALL_DIR="${HOME}/.local/bin"`
- `BINARY_NAME="cli-lsp-client"`
- Detects OS (darwin/linux) and arch (x64/arm64)
- Constructs artifact name: `cli-lsp-client-{os}-{arch}`
- Downloads from `https://github.com/${REPO}/releases/latest/download/${ARTIFACT}`
- Installs to `~/.local/bin/cli-lsp-client`, chmod +x
- PATH check with suggestion to add `~/.local/bin` to PATH

## Phase 7: CI Workflow Changes

### Modify: `.github/workflows/version.yml`

After the changesets action step (which runs `bun run release --publish-only`, already building all platform binaries into `dist/`), add steps to upload the **already-built** binaries to the GitHub release. No rebuild needed — just copy them out with flat names.

```yaml
- name: Check if release needs binaries
  id: check-release
  run: |
    VERSION="v$(jq -r .version package.json)"
    if gh release view "$VERSION" &>/dev/null; then
      ASSET_COUNT=$(gh release view "$VERSION" --json assets --jq '.assets | length')
      if [ "$ASSET_COUNT" -eq 0 ]; then
        echo "needs_binaries=true" >> $GITHUB_OUTPUT
        echo "version=$VERSION" >> $GITHUB_OUTPUT
      fi
    fi
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

- name: Upload binaries to release
  if: steps.check-release.outputs.needs_binaries == 'true'
  run: |
    cp dist/cli-lsp-client-linux-x64/bin/cli-lsp-client cli-lsp-client-linux-x64
    cp dist/cli-lsp-client-linux-arm64/bin/cli-lsp-client cli-lsp-client-linux-arm64
    cp dist/cli-lsp-client-darwin-x64/bin/cli-lsp-client cli-lsp-client-darwin-x64
    cp dist/cli-lsp-client-darwin-arm64/bin/cli-lsp-client cli-lsp-client-darwin-arm64
    gh release upload "${{ steps.check-release.outputs.version }}" \
      cli-lsp-client-linux-x64 \
      cli-lsp-client-linux-arm64 \
      cli-lsp-client-darwin-x64 \
      cli-lsp-client-darwin-arm64 \
      --clobber
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

The binaries are already built by `bun run release --publish-only` (the changesets publish command). We just copy them from their npm package directory structure (`dist/cli-lsp-client-{os}-{arch}/bin/cli-lsp-client`) to flat-named files (`cli-lsp-client-{os}-{arch}`) for the GitHub release upload. No Windows binary since the install script only supports Unix.

## Files Summary

| Action | File                            | Purpose                                              |
| ------ | ------------------------------- | ---------------------------------------------------- |
| Create | `src/update-types.ts`           | Shared types                                         |
| Create | `src/update-state.ts`           | State persistence                                    |
| Create | `src/update.ts`                 | Core update functions                                |
| Create | `src/auto-update.ts`            | Orchestrator                                         |
| Create | `src/updater-worker.ts`         | Background worker                                    |
| Create | `src/commands/update.ts`        | Manual update command                                |
| Create | `install.sh`                    | Bash install script                                  |
| Create | `tests/update-state.test.ts`    | State tests                                          |
| Create | `tests/update.test.ts`          | Core function tests                                  |
| Create | `tests/auto-update.test.ts`     | Orchestrator tests                                   |
| Create | `tests/updater-worker.test.ts`  | Worker tests                                         |
| Modify | `src/lsp/config.ts`             | Add updateBehavior to schema                         |
| Modify | `src/cli.ts`                    | Wire up update worker + auto-update + update command |
| Modify | `.github/workflows/version.yml` | Add binary build+upload to GitHub releases           |

## Verification

1. `bun run typecheck` — no type errors
2. `bun test` — all new and existing tests pass
3. `bun run build` — verify the built binary includes update code
4. Manual test: `bun run dev -- update` — should check GitHub API (will say "already on latest" or "no releases found")
5. Manual test: `bun run dev -- --update-worker <version> <path> auto` — should run worker and exit
6. Verify install.sh works: `bash install.sh` (requires a GitHub release to exist)
7. Verify version.yml diff looks correct for CI
